[
  {
    "objectID": "posts/lab2-post.html",
    "href": "posts/lab2-post.html",
    "title": "Lab 2 Blog",
    "section": "",
    "text": "The list below is a non-exhaustive list of ideas of things you could write about if you’re struggling to come up with ideas.\nWhat is something interesting you learned recently in lab or lecture? How do you feel like the course is helping you to grow as a person? Reflect on the character traits you listed at the beginning of the course for ideas about specific areas of growth to reflect on. What did you think about a recent AI prototype? How did your use of AI shape your thinking about what role these tools might play in the future of digital hardware design? Search the Internet for a recent article related to embedded systems. Reflect on those systems through the lens of what you’re learning in MicroPs. What are some ideas you’re thinking about exploring in your project and why?"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Blog 1",
    "section": "",
    "text": "My initial learning goals involve building a strong foundation in embedded systems design. With a basic understanding of digital design and microcontroller programming, I hope to deepen my knowledge and skills.\nThe first goal is to become proficient in designing and implementing combinational and sequential circuits on FPGAs. I also want to gain hands-on experience with microcontrollers to create functional embedded systems. Additionally, my goal is to develop the ability to select the suitable hardware components and to debug circuits. Beyond the technical skills, I want to improve my ability to communicate complex technical results clearly and professionally through presentations and reports."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "hmc-e155-portforlio",
    "section": "",
    "text": "This lab explores generating simple audio using a microcontroller’s General-Purpose Input/Output (GPIO) pin to produce square waves at specific frequencies and durations, which allows the microcontroller (MCU) to output musical notes. By programming the MCU with sequences of frequencies and durations, simple melodies are generated, specifically Beethoven’s “Für Elise” and “Ode to Joy.” The lab required creating a custom library to interface directly with the hardware timer peripherals on the STM32L432KC microcontroller, instead of using the CMSIS library.\n\n\n\nThe system design began with configuring the MCU clock speed to 80 MHz through the RCC library, providing the necessary precision to generate the desired frequency and duration intervals. We then set up the timers with different prescaler values, allowing us to achieve the correct time base for both PWM and delay functionalities. To control sound duration, we configured a timer with a prescaler of 7999, resulting in a time base of 0.1 ms. This was calculated using the formula:\n\\[ \\text{Time base} = \\frac{80 \\, \\text{MHz}}{\\text{TIM\\_PSC} + 1} \\]\nwhere \\(\\text{TIM\\_PSC}\\) is the prescaler value. This configuration allowed precise timing control within the range specified, as each tick represented 0.1 ms. For PWM, we used a different prescaler of 799 to obtain a finer time base, set to 10 μs, allowing us to control frequencies in the desired audio range by dynamically adjusting the auto-reload register (\\(\\text{TIM\\_ARR}\\)).\nOnce the timers were configured, we implemented delay_millis() and setFreq() functions. The delay_millis() function utilizes the timer’s 0.1 ms time base, setting \\(\\text{TIM\\_ARR}\\) to the desired duration in milliseconds. It waits for the timer to overflow, allowing precise control over sound duration. For frequency adjustments, setFreq() calculates the appropriate auto-reload value based on the target frequency:\n\\[ \\text{TIM\\_ARR} = \\frac{100000}{\\text{frequency}} \\]\nThis relationship allows dynamic adjustments to the PWM frequency, outputting sound at the specified pitch. Additionally, a 50% duty cycle was achieved by setting the capture/compare register (\\(\\text{TIM\\_CCR1}\\)) to half the value of \\(\\text{TIM\\_ARR}\\).\nAdditionally, the potentiometer provided additional control over output volume. Connected to the PWM output stage, it adjusts the duty cycle, allowing real-time modulation of sound intensity. This added flexibility in testing and adjusting the sound output without code changes, enabling smoother interactions during experimentation.\n\n\nTo ensure that the frequencies generated were within 1% of the expected values (220 Hz to 1000 Hz), I calculated the theoretical frequency for each desired frequency based on the \\(\\text{TIM\\_ARR}\\) value and compared the result. The formula for calculating the output frequency from the \\(\\text{TIM\\_ARR}\\) value is:\n\\[ \\text{Frequency} = \\frac{100000}{\\text{TIM\\_ARR}} \\]\nI calculated the \\(\\text{TIM\\_ARR}\\) value, and recalculated the frequency to verify that it was within the acceptable range.\n\nFor 220 Hz:\n\\[ \\text{TIM\\_ARR} = \\frac{100000}{220} = 454.545 \\quad \\text{(rounded to 455)} \\]\nRecalculating the frequency from this value:\n\\[ \\text{Frequency} = \\frac{100000}{455} \\approx 219.78 \\, \\text{Hz} \\]\nThe error is:\n\\[ \\text{Error} = \\frac{220 - 219.78}{220} \\times 100 &lt; 0.1\\% \\]\nFor 999 Hz:\n\\[ \\text{TIM\\_ARR} = \\frac{100000}{999} = 100.1 \\quad \\text{(rounded to 100)}\\]\nRecalculating the frequency from this value:\n\\[ \\text{Frequency} = \\frac{100000}{100} = 1000 \\, \\text{Hz} \\]\nThe error is:\n\\[ \\text{Error} = \\frac{1000 - 999}{1000} \\times 100 = 0.1\\% \\]\n\nThe error was found to be less than 1%, confirming the accuracy of the generated frequencies within the desired tolerance.\n\n\n\n\nFor 262 Hz (minimum frequency):\n\\[ \\text{TIM\\_ARR} = \\frac{100000}{262} \\approx 381 \\]\nFor 1319 Hz (maximum frequency):\n\\[ \\text{TIM\\_ARR} = \\frac{100000}{1319} \\approx 76 \\]\n\nThese calculations verify that the PWM configuration effectively generates the desired frequencies, with \\(\\text{TIM\\_ARR}\\) values properly scaled for the timer’s time base.\nSimilarly, the duration limit is from 125 ms to 1 second. Given the 0.1 ms time base, the corresponding \\(\\text{TIM\\_ARR}\\) values for these limits using are calculated:\n\\[ \\text{TIM\\_ARR} = \\text{duration (ms)} \\times 10 \\]\n\nFor 125 ms (minimum duration):\n\\[ \\text{TIM\\_ARR} = 125 \\times 10 = 1250 \\]\nFor 1 second (maximum duration):\n\\[ \\text{TIM\\_ARR} = 1000 \\times 10 = 10000 \\]\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n Figure 1. Schematic of the physical circuit\nThe schematic hows the complete circuit design for audio output, including the potentiometer used to control volume. The microcontroller’s GPIO pin outputs PWM signals, which pass through the potentiometer to adjust the amplitude of the sound. By adjusting the potentiometer, the voltage level sent to the speaker can be controlled.\n\n\n\nBelow is a demonstration of the result, showing the successful playback of notes.\n\n\nYour browser does not support the video tag. \n\n\n\nThis lab demonstrated successful sound generation using the MCU’s GPIO pin to output square waves at specific frequencies and durations. The MCU was able to produce simple melodies by sequencing notes through code. I spent approximately 12 hours working on this lab."
  },
  {
    "objectID": "labs/lab4/lab4.html#lab-4-digital-audio",
    "href": "labs/lab4/lab4.html#lab-4-digital-audio",
    "title": "hmc-e155-portforlio",
    "section": "",
    "text": "This lab explores generating simple audio using a microcontroller’s General-Purpose Input/Output (GPIO) pin to produce square waves at specific frequencies and durations, which allows the microcontroller (MCU) to output musical notes. By programming the MCU with sequences of frequencies and durations, simple melodies are generated, specifically Beethoven’s “Für Elise” and “Ode to Joy.” The lab required creating a custom library to interface directly with the hardware timer peripherals on the STM32L432KC microcontroller, instead of using the CMSIS library.\n\n\n\nThe system design began with configuring the MCU clock speed to 80 MHz through the RCC library, providing the necessary precision to generate the desired frequency and duration intervals. We then set up the timers with different prescaler values, allowing us to achieve the correct time base for both PWM and delay functionalities. To control sound duration, we configured a timer with a prescaler of 7999, resulting in a time base of 0.1 ms. This was calculated using the formula:\n\\[ \\text{Time base} = \\frac{80 \\, \\text{MHz}}{\\text{TIM\\_PSC} + 1} \\]\nwhere \\(\\text{TIM\\_PSC}\\) is the prescaler value. This configuration allowed precise timing control within the range specified, as each tick represented 0.1 ms. For PWM, we used a different prescaler of 799 to obtain a finer time base, set to 10 μs, allowing us to control frequencies in the desired audio range by dynamically adjusting the auto-reload register (\\(\\text{TIM\\_ARR}\\)).\nOnce the timers were configured, we implemented delay_millis() and setFreq() functions. The delay_millis() function utilizes the timer’s 0.1 ms time base, setting \\(\\text{TIM\\_ARR}\\) to the desired duration in milliseconds. It waits for the timer to overflow, allowing precise control over sound duration. For frequency adjustments, setFreq() calculates the appropriate auto-reload value based on the target frequency:\n\\[ \\text{TIM\\_ARR} = \\frac{100000}{\\text{frequency}} \\]\nThis relationship allows dynamic adjustments to the PWM frequency, outputting sound at the specified pitch. Additionally, a 50% duty cycle was achieved by setting the capture/compare register (\\(\\text{TIM\\_CCR1}\\)) to half the value of \\(\\text{TIM\\_ARR}\\).\nAdditionally, the potentiometer provided additional control over output volume. Connected to the PWM output stage, it adjusts the duty cycle, allowing real-time modulation of sound intensity. This added flexibility in testing and adjusting the sound output without code changes, enabling smoother interactions during experimentation.\n\n\nTo ensure that the frequencies generated were within 1% of the expected values (220 Hz to 1000 Hz), I calculated the theoretical frequency for each desired frequency based on the \\(\\text{TIM\\_ARR}\\) value and compared the result. The formula for calculating the output frequency from the \\(\\text{TIM\\_ARR}\\) value is:\n\\[ \\text{Frequency} = \\frac{100000}{\\text{TIM\\_ARR}} \\]\nI calculated the \\(\\text{TIM\\_ARR}\\) value, and recalculated the frequency to verify that it was within the acceptable range.\n\nFor 220 Hz:\n\\[ \\text{TIM\\_ARR} = \\frac{100000}{220} = 454.545 \\quad \\text{(rounded to 455)} \\]\nRecalculating the frequency from this value:\n\\[ \\text{Frequency} = \\frac{100000}{455} \\approx 219.78 \\, \\text{Hz} \\]\nThe error is:\n\\[ \\text{Error} = \\frac{220 - 219.78}{220} \\times 100 &lt; 0.1\\% \\]\nFor 999 Hz:\n\\[ \\text{TIM\\_ARR} = \\frac{100000}{999} = 100.1 \\quad \\text{(rounded to 100)}\\]\nRecalculating the frequency from this value:\n\\[ \\text{Frequency} = \\frac{100000}{100} = 1000 \\, \\text{Hz} \\]\nThe error is:\n\\[ \\text{Error} = \\frac{1000 - 999}{1000} \\times 100 = 0.1\\% \\]\n\nThe error was found to be less than 1%, confirming the accuracy of the generated frequencies within the desired tolerance.\n\n\n\n\nFor 262 Hz (minimum frequency):\n\\[ \\text{TIM\\_ARR} = \\frac{100000}{262} \\approx 381 \\]\nFor 1319 Hz (maximum frequency):\n\\[ \\text{TIM\\_ARR} = \\frac{100000}{1319} \\approx 76 \\]\n\nThese calculations verify that the PWM configuration effectively generates the desired frequencies, with \\(\\text{TIM\\_ARR}\\) values properly scaled for the timer’s time base.\nSimilarly, the duration limit is from 125 ms to 1 second. Given the 0.1 ms time base, the corresponding \\(\\text{TIM\\_ARR}\\) values for these limits using are calculated:\n\\[ \\text{TIM\\_ARR} = \\text{duration (ms)} \\times 10 \\]\n\nFor 125 ms (minimum duration):\n\\[ \\text{TIM\\_ARR} = 125 \\times 10 = 1250 \\]\nFor 1 second (maximum duration):\n\\[ \\text{TIM\\_ARR} = 1000 \\times 10 = 10000 \\]\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n Figure 1. Schematic of the physical circuit\nThe schematic hows the complete circuit design for audio output, including the potentiometer used to control volume. The microcontroller’s GPIO pin outputs PWM signals, which pass through the potentiometer to adjust the amplitude of the sound. By adjusting the potentiometer, the voltage level sent to the speaker can be controlled.\n\n\n\nBelow is a demonstration of the result, showing the successful playback of notes.\n\n\nYour browser does not support the video tag. \n\n\n\nThis lab demonstrated successful sound generation using the MCU’s GPIO pin to output square waves at specific frequencies and durations. The MCU was able to produce simple melodies by sequencing notes through code. I spent approximately 12 hours working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "hmc-e155-portforlio",
    "section": "",
    "text": "The goal of this lab was to implement a time-multiplexing scheme to drive two common anode 7-segment displays using a single set of FPGA I/O pins. The system uses two sets of 4 DIP switches as inputs for each 7-segment display, and the sum of the hexadecimal numbers from the DIP switches is displayed on five LEDs. By employing time-multiplexing, I could efficiently control both digits without requiring a large number of I/O pins, making the design more resource-efficient while achieving the desired functionality.\n\n\n\nIn this lab, the FPGA controlled the 7-segment displays through time-multiplexing, which is a technique that rapidly switches between two displays at a rate fast enough to make the flickering imperceptible to the human eye. The common anodes of the two 7-segment displays were connected to PNP transistors, allowing the FPGA to avoid driving large currents. Each time a segment of the display needs to be lit, the corresponding cathode is driven by the FPGA, while the common anode is switched on for the display currently being activated.\n\n\nThe onboard high-speed oscillator (HSOSC) was used in conjunction with a clock divider to generate an enable signal. This enable signal was responsible for controlling the common anode of each 7-segment display. Only one of the displays is turned on at a time, and the switching between displays occurs at a frequency high enough to prevent visible flickering.\nTo ensure that the multiplexing rate was fast enough to avoid flickering, the system required an effective switching frequency. Given that I am multiplexing two displays, the switching rate can be calculated based on the target frequency for display updates. For instance, if I want to refresh the display at 50 Hz, the switching rate must be twice this value, i.e., 100 Hz, because there are two displays.\n\\[\nf_{\\text{switch}} = 2 \\times f_{\\text{display}}\n\\]\nWhere: - ( f_{} ) is the frequency at which the displays switch, - ( f_{} ) is the desired display refresh rate.\nAssuming a desired display refresh rate of 50 Hz, the switching frequency should be 100 Hz. This rate is fast enough to ensure that each display is on for 10 milliseconds, and no flicker is perceptible.\n\n\n\nThe seven segments of each display are driven by FPGA pins. A 3.3V supply is used for the anodes of the diodes in the 7-segment displays, and the FPGA sets the cathodes low to turn on each segment. To ensure safe operation and prevent excessive current from flowing through the LEDs, a current-limiting resistor is placed in series with each segment. The resistor value is chosen to allow a current of about 20mA through each segment when it is turned on, which is within the recommended operating range for these types of LEDs.\n\n\n\nThe 4 DIP switches for each display represent a hexadecimal number. The FPGA decodes the hexadecimal input and displays the corresponding digits on the 7-segment displays. A decoder module in the Verilog design converts the hexadecimal values from the DIP switches into the appropriate signals for the segments of the display.\nThe calculation for determining the correct segment signals involves mapping the hexadecimal digits (0-9 and A-F) to the corresponding segments on the display. Each segment of the 7-segment display is turned on or off according to the binary representation of the hexadecimal digit.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n Figure 1. Block diagram of the Verilog design\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module includes two submodules: 1. Seven Segment Decoder Module (seven_seg_decoder): This module takes the hexadecimal input from the DIP switches and converts it into the appropriate signals to drive the 7-segment display. 2. Time Multiplexing Module (time_multiplexing): This module controls the timing for multiplexing the two displays, ensuring that only one display is activated at a time and that the switching is fast enough to avoid flickering.\n\n\n\n Figure 2. Schematic of the physical circuit\nFigure 2 shows the physical layout of the design. It illustrates the connections between the FPGA and the two 7-segment displays, as well as the integration of the common anode control using the PNP transistors.\n\n\n\n\n\n\n Figure 3. A screenshot of a QuestaSim simulation demonstrating the clock generated for displaying.\nThe simulation results shown in Figure 3 demonstrate the clock signal generated by the time-multiplexing module. This clock signal is used to enable the common anode for each 7-segment display in turn, ensuring that the displays are switched on and off at the correct rate.\n Figure 4. A screenshot of a QuestaSim simulation demonstrating the output displayed on the multiplexed 7-segment display.\nFigure 4 shows the simulation output for the two multiplexed 7-segment displays. The simulation confirms that the correct segments are lit for each display, and the switching occurs as expected. The output matches the expected result based on the input from the DIP switches, and the system functions correctly with no visible flickering.\n\n\n\nThe results of the simulation and the physical implementation confirm the correctness of the design. The two 7-segment displays successfully show the hexadecimal sum of the DIP switches. The multiplexing works as expected, with the switching rate high enough to prevent any perceptible flickering.\nAdditionally, the current-limiting resistors ensure that the segments are driven within their safe operating range, providing sufficient brightness without drawing excessive current. The use of PNP transistors for the common anode control prevents the FPGA from having to drive large currents, which helps protect the FPGA pins.\n\n\n\n\nThe design successfully implements a time-multiplexed system to drive two 7-segment displays using only seven FPGA I/O pins. The multiplexing scheme, along with the use of PNP transistors to control the common anodes, allows for efficient and effective use of FPGA resources. The system displays the sum of two hexadecimal numbers, as input via the DIP switches, without any visible flickering or blending. The clock divider and time-multiplexing techniques were successfully applied, and the design meets the expected functional requirements. I spent a total of 10 hours working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "hmc-e155-portforlio",
    "section": "",
    "text": "The goal of this lab was to implement a time-multiplexing scheme to drive two common anode 7-segment displays using a single set of FPGA I/O pins. The system uses two sets of 4 DIP switches as inputs for each 7-segment display, and the sum of the hexadecimal numbers from the DIP switches is displayed on five LEDs. By employing time-multiplexing, I could efficiently control both digits without requiring a large number of I/O pins, making the design more resource-efficient while achieving the desired functionality.\n\n\n\nIn this lab, the FPGA controlled the 7-segment displays through time-multiplexing, which is a technique that rapidly switches between two displays at a rate fast enough to make the flickering imperceptible to the human eye. The common anodes of the two 7-segment displays were connected to PNP transistors, allowing the FPGA to avoid driving large currents. Each time a segment of the display needs to be lit, the corresponding cathode is driven by the FPGA, while the common anode is switched on for the display currently being activated.\n\n\nThe onboard high-speed oscillator (HSOSC) was used in conjunction with a clock divider to generate an enable signal. This enable signal was responsible for controlling the common anode of each 7-segment display. Only one of the displays is turned on at a time, and the switching between displays occurs at a frequency high enough to prevent visible flickering.\nTo ensure that the multiplexing rate was fast enough to avoid flickering, the system required an effective switching frequency. Given that I am multiplexing two displays, the switching rate can be calculated based on the target frequency for display updates. For instance, if I want to refresh the display at 50 Hz, the switching rate must be twice this value, i.e., 100 Hz, because there are two displays.\n\\[\nf_{\\text{switch}} = 2 \\times f_{\\text{display}}\n\\]\nWhere: - ( f_{} ) is the frequency at which the displays switch, - ( f_{} ) is the desired display refresh rate.\nAssuming a desired display refresh rate of 50 Hz, the switching frequency should be 100 Hz. This rate is fast enough to ensure that each display is on for 10 milliseconds, and no flicker is perceptible.\n\n\n\nThe seven segments of each display are driven by FPGA pins. A 3.3V supply is used for the anodes of the diodes in the 7-segment displays, and the FPGA sets the cathodes low to turn on each segment. To ensure safe operation and prevent excessive current from flowing through the LEDs, a current-limiting resistor is placed in series with each segment. The resistor value is chosen to allow a current of about 20mA through each segment when it is turned on, which is within the recommended operating range for these types of LEDs.\n\n\n\nThe 4 DIP switches for each display represent a hexadecimal number. The FPGA decodes the hexadecimal input and displays the corresponding digits on the 7-segment displays. A decoder module in the Verilog design converts the hexadecimal values from the DIP switches into the appropriate signals for the segments of the display.\nThe calculation for determining the correct segment signals involves mapping the hexadecimal digits (0-9 and A-F) to the corresponding segments on the display. Each segment of the 7-segment display is turned on or off according to the binary representation of the hexadecimal digit.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n Figure 1. Block diagram of the Verilog design\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module includes two submodules: 1. Seven Segment Decoder Module (seven_seg_decoder): This module takes the hexadecimal input from the DIP switches and converts it into the appropriate signals to drive the 7-segment display. 2. Time Multiplexing Module (time_multiplexing): This module controls the timing for multiplexing the two displays, ensuring that only one display is activated at a time and that the switching is fast enough to avoid flickering.\n\n\n\n Figure 2. Schematic of the physical circuit\nFigure 2 shows the physical layout of the design. It illustrates the connections between the FPGA and the two 7-segment displays, as well as the integration of the common anode control using the PNP transistors.\n\n\n\n\n\n\n Figure 3. A screenshot of a QuestaSim simulation demonstrating the clock generated for displaying.\nThe simulation results shown in Figure 3 demonstrate the clock signal generated by the time-multiplexing module. This clock signal is used to enable the common anode for each 7-segment display in turn, ensuring that the displays are switched on and off at the correct rate.\n Figure 4. A screenshot of a QuestaSim simulation demonstrating the output displayed on the multiplexed 7-segment display.\nFigure 4 shows the simulation output for the two multiplexed 7-segment displays. The simulation confirms that the correct segments are lit for each display, and the switching occurs as expected. The output matches the expected result based on the input from the DIP switches, and the system functions correctly with no visible flickering.\n\n\n\nThe results of the simulation and the physical implementation confirm the correctness of the design. The two 7-segment displays successfully show the hexadecimal sum of the DIP switches. The multiplexing works as expected, with the switching rate high enough to prevent any perceptible flickering.\nAdditionally, the current-limiting resistors ensure that the segments are driven within their safe operating range, providing sufficient brightness without drawing excessive current. The use of PNP transistors for the common anode control prevents the FPGA from having to drive large currents, which helps protect the FPGA pins.\n\n\n\n\nThe design successfully implements a time-multiplexed system to drive two 7-segment displays using only seven FPGA I/O pins. The multiplexing scheme, along with the use of PNP transistors to control the common anodes, allows for efficient and effective use of FPGA resources. The system displays the sum of two hexadecimal numbers, as input via the DIP switches, without any visible flickering or blending. The clock divider and time-multiplexing techniques were successfully applied, and the design meets the expected functional requirements. I spent a total of 10 hours working on this lab."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portforlio",
    "section": "",
    "text": "Zhian Zhou is an Engineering major student at Harvey Mudd College."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab 2 Blog\n\n\n\n\n\nMultiplexed 7-Segment Display\n\n\n\n\n\nSep 12, 2024\n\n\nZhian Zhou\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1 Blog\n\n\n\n\n\nFPGA and MCU Setup and Testing\n\n\n\n\n\nSep 5, 2024\n\n\nZhian Zhou\n\n\n\n\n\n\n\n\n\n\n\n\nBlog 1\n\n\n\n\n\nInitial learning goals\n\n\n\n\n\nAug 30, 2024\n\n\nZhian Zhou\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "hmc-e155-portforlio",
    "section": "",
    "text": "The goal of Lab 1 was to set up the FPGA and MCU board and design a circuit that controls three onboard LEDs and a common cathode 7-segment display using four DIP switches. The 7-segment display is capable of displaying a single hexadecimal digit, while the LEDs are used to indicate different conditions based on the state of the DIP switches. Specifically, one LED is activated when one of the first two DIP switches is turned on, another LED is turned on when both of the last two DIP switches are on, and a third LED blinks at a frequency of approximately 2.4 Hz. This setup is designed to demonstrate basic digital logic functionality, display control, and LED behavior using an FPGA.\n\n\n\nThe FPGA design is based on a clock divider and display decoder to manage the various outputs. The onboard low-speed oscillator (LSOSC) from the iCE40 UltraPlus primitive library is used, which operates at a frequency of 10 kHz. This clock frequency is suitable for generating a 2.4 Hz signal for the blinking LED. A clock divider module is implemented in Verilog to divide the 10 kHz clock signal down to the desired frequency. Specifically, a counter is used within the clock divider to produce the necessary 2.4 Hz signal, which will toggle the blinking LED.\nThe 7-segment display consists of diodes for each segment, where the FPGA output signals drive the diodes low to light them up. The design ensures that the diodes on the 7-segment display receive a current draw between 5 mA and 20 mA while maintaining a forward voltage of around 2.1 V. This is important to prevent damage to the diodes and to ensure proper display brightness. To achieve this, a current-limiting resistor is placed in series with each segment. The value of the resistor is calculated to allow the proper current range through the diodes. After testing various resistor values, I selected a 68-ohm resistor to ensure the optimal current and brightness for the display.\nThe fs DIP switches are used as inputs to control the state of the LEDs. The first two DIP switches control one LED, while the last two DIP switches control another LED. A third LED blinks at a frequency of approximately 2.4 Hz, generated by the clock divider.\n\n\nTo determine the appropriate value for the current-limiting resistors for the 7-segment display, I used the following approach:\n\nForward voltage of LED (Vf): 2.1 V (typical for standard red LEDs).\nSupply voltage (Vcc): 3.3 V.\nDesired current (I): Between 5 mA and 20 mA.\n\nUsing Ohm’s law, the resistor value is calculated as:\n\\[\nR = \\frac{V_{cc} - V_f}{I}\n\\]\nFor a maximum current of 20 mA:\n\\[\nR = \\frac{3.3 \\, \\text{V} - 2.1 \\, \\text{V}}{0.02 \\, \\text{A}} = 60 \\, \\Omega\n\\]\nThis is the maximum resistance value. Since I want to limit the current to below 20 mA, a resistor of 68 ohms was chosen as it provides a good balance between brightness and current safety.\n\n\n\n\nThe source code for the FPGA project, including the Verilog code for the clock divider and 7-segment decoder modules, can be found in the associated GitHub repository.\n\n\n Figure 1. Block diagram of the Verilog design\nThe block diagram in Figure 1 illustrates the architecture of the design. The top-level module (top) contains two submodules: 1. Clock Divider (clock_divider): This module is responsible for dividing the 10 kHz clock to generate the 2.4 Hz signal needed for blinking one of the LEDs. 2. 7-Segment Decoder (seven_seg_decoder): This module takes a 4-bit input (the DIP switches) and decodes it to control the appropriate segments of the 7-segment display, outputting the corresponding hexadecimal digit.\n\n\n\n Figure 2. Schematic of the physical circuit\nFigure 2 shows the physical layout of the design, illustrating how the DIP switches, LEDs, and 7-segment display are connected to the FPGA.\n\n\n\n\n\n\n Figure 3. A screenshot of a QuestaSim simulation demonstrating the display output is identical to the expected output.\nThe simulation results in Figure 3 confirm that the 7-segment display outputs the correct hexadecimal digits corresponding to the input from the DIP switches. The expected output was verified through a testbench simulation in QuestaSim, where the values of the DIP switches were varied and the display output was observed to match the correct hexadecimal digit for each case. This demonstrates that the seven_seg_decoder module is functioning as intended.\n\n\n\nThe LEDs function as expected based on the states of the DIP switches. When one of the first two DIP switches is turned on, the first LED lights up. When both of the last two DIP switches are on, the second LED lights up. The third LED blinks at a rate of approximately 2.4 Hz, as determined by the clock divider module. This blinking frequency was validated through measurement and observation using an oscilloscope.\nThe resistor values used in the 7-segment display circuitry were verified to be appropriate, as the display was bright and functional without overloading the diodes. The current-limiting resistors ensured that the diodes were not damaged, and the display showed clear, readable digits.\n\n\n\n\nThe design successfully implemented the control of three onboard LEDs and a 7-segment display using four DIP switches on the FPGA. The clock divider module accurately generated a 2.4 Hz signal, which caused the third LED to blink as expected. The 7-segment display showed the correct hexadecimal digits based on the DIP switch inputs, and the LEDs responded correctly to the switch settings. The resistor values for the current-limiting resistors were chosen appropriately, ensuring both the proper brightness of the display and the safety of the diodes. I spent a total of 8 hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "hmc-e155-portforlio",
    "section": "",
    "text": "The goal of Lab 1 was to set up the FPGA and MCU board and design a circuit that controls three onboard LEDs and a common cathode 7-segment display using four DIP switches. The 7-segment display is capable of displaying a single hexadecimal digit, while the LEDs are used to indicate different conditions based on the state of the DIP switches. Specifically, one LED is activated when one of the first two DIP switches is turned on, another LED is turned on when both of the last two DIP switches are on, and a third LED blinks at a frequency of approximately 2.4 Hz. This setup is designed to demonstrate basic digital logic functionality, display control, and LED behavior using an FPGA.\n\n\n\nThe FPGA design is based on a clock divider and display decoder to manage the various outputs. The onboard low-speed oscillator (LSOSC) from the iCE40 UltraPlus primitive library is used, which operates at a frequency of 10 kHz. This clock frequency is suitable for generating a 2.4 Hz signal for the blinking LED. A clock divider module is implemented in Verilog to divide the 10 kHz clock signal down to the desired frequency. Specifically, a counter is used within the clock divider to produce the necessary 2.4 Hz signal, which will toggle the blinking LED.\nThe 7-segment display consists of diodes for each segment, where the FPGA output signals drive the diodes low to light them up. The design ensures that the diodes on the 7-segment display receive a current draw between 5 mA and 20 mA while maintaining a forward voltage of around 2.1 V. This is important to prevent damage to the diodes and to ensure proper display brightness. To achieve this, a current-limiting resistor is placed in series with each segment. The value of the resistor is calculated to allow the proper current range through the diodes. After testing various resistor values, I selected a 68-ohm resistor to ensure the optimal current and brightness for the display.\nThe fs DIP switches are used as inputs to control the state of the LEDs. The first two DIP switches control one LED, while the last two DIP switches control another LED. A third LED blinks at a frequency of approximately 2.4 Hz, generated by the clock divider.\n\n\nTo determine the appropriate value for the current-limiting resistors for the 7-segment display, I used the following approach:\n\nForward voltage of LED (Vf): 2.1 V (typical for standard red LEDs).\nSupply voltage (Vcc): 3.3 V.\nDesired current (I): Between 5 mA and 20 mA.\n\nUsing Ohm’s law, the resistor value is calculated as:\n\\[\nR = \\frac{V_{cc} - V_f}{I}\n\\]\nFor a maximum current of 20 mA:\n\\[\nR = \\frac{3.3 \\, \\text{V} - 2.1 \\, \\text{V}}{0.02 \\, \\text{A}} = 60 \\, \\Omega\n\\]\nThis is the maximum resistance value. Since I want to limit the current to below 20 mA, a resistor of 68 ohms was chosen as it provides a good balance between brightness and current safety.\n\n\n\n\nThe source code for the FPGA project, including the Verilog code for the clock divider and 7-segment decoder modules, can be found in the associated GitHub repository.\n\n\n Figure 1. Block diagram of the Verilog design\nThe block diagram in Figure 1 illustrates the architecture of the design. The top-level module (top) contains two submodules: 1. Clock Divider (clock_divider): This module is responsible for dividing the 10 kHz clock to generate the 2.4 Hz signal needed for blinking one of the LEDs. 2. 7-Segment Decoder (seven_seg_decoder): This module takes a 4-bit input (the DIP switches) and decodes it to control the appropriate segments of the 7-segment display, outputting the corresponding hexadecimal digit.\n\n\n\n Figure 2. Schematic of the physical circuit\nFigure 2 shows the physical layout of the design, illustrating how the DIP switches, LEDs, and 7-segment display are connected to the FPGA.\n\n\n\n\n\n\n Figure 3. A screenshot of a QuestaSim simulation demonstrating the display output is identical to the expected output.\nThe simulation results in Figure 3 confirm that the 7-segment display outputs the correct hexadecimal digits corresponding to the input from the DIP switches. The expected output was verified through a testbench simulation in QuestaSim, where the values of the DIP switches were varied and the display output was observed to match the correct hexadecimal digit for each case. This demonstrates that the seven_seg_decoder module is functioning as intended.\n\n\n\nThe LEDs function as expected based on the states of the DIP switches. When one of the first two DIP switches is turned on, the first LED lights up. When both of the last two DIP switches are on, the second LED lights up. The third LED blinks at a rate of approximately 2.4 Hz, as determined by the clock divider module. This blinking frequency was validated through measurement and observation using an oscilloscope.\nThe resistor values used in the 7-segment display circuitry were verified to be appropriate, as the display was bright and functional without overloading the diodes. The current-limiting resistors ensured that the diodes were not damaged, and the display showed clear, readable digits.\n\n\n\n\nThe design successfully implemented the control of three onboard LEDs and a 7-segment display using four DIP switches on the FPGA. The clock divider module accurately generated a 2.4 Hz signal, which caused the third LED to blink as expected. The 7-segment display showed the correct hexadecimal digits based on the DIP switch inputs, and the LEDs responded correctly to the switch settings. The resistor values for the current-limiting resistors were chosen appropriately, ensuring both the proper brightness of the display and the safety of the diodes. I spent a total of 8 hours working on this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "hmc-e155-portforlio",
    "section": "",
    "text": "In Lab 5, the primary goal was to implement an interrupt-driven algorithm for reading quadrature encoder signals and converting them into motor velocity and direction readings. A quadrature encoder produces two offset pulse signals that can be interpreted to detect both the speed and direction of a rotating motor. By monitoring these signals, it is possible to determine whether the motor is moving clockwise or counter-clockwise and calculate the rotational speed in revolutions per second. This lab aims to accurately read these encoder pulses using interrupt-based routines on the MCU and display the measured speed and direction with a refresh rate of at least 1 Hz.\n\n\n\nThe design of this system primarily involved configuring two GPIO pins on the MCU to receive the quadrature encoder’s A and B signals, with PA5 and PA8 designated for this purpose. External interrupts (EXTI) were configured on these pins to detect falling edges, thus triggering an interrupt on each pulse received from the encoder. This enabled precise tracking of pulse events for calculating speed and determining the direction. The phase relationship between the two signals was used to infer the direction of rotation: when signal A leads signal B, the motor was identified as rotating clockwise, and vice versa for counter-clockwise.\nIn addition to the GPIO and EXTI setup, two timers were configured on the MCU. TIM16 was used to measure the time intervals between successive pulses, while TIM2 was configured to enforce a 0.5 Hz delay for the periodic display of results. The motor’s velocity in revolutions per second was calculated by inversely relating the interval time to speed, based on the formula speed = 1 / (0.000001 * interval * 120 * 4). This formula incorporated constants to account for the characteristics of the quadrature encoder, such as its pulses per revolution (120) and phase offsets (90°). Finally, the calculated velocity and direction were displayed via a USART output with a 0.5 Hz refresh rate.\n\n\n\nThe source code for the project can be found in the associated Github repository.  Figure 1. Flowchart illustrating the main steps of the program and function calls.\n Figure 2. Schematic of the physical circuit\n\n\n\nThe implemented system successfully captured the direction of motor rotation and calculated the rotational velocity, displaying these values on debug terminal with a 0.5 Hz refresh rate. The direction detection proved to be accurate due to the use of phase analysis between signals A and B, which consistently indicated whether the motor was moving clockwise or counter-clockwise. For the velocity measurement, the calculated speed in revolutions per second is closed to the motor’s actual speed but not very accurate.\nOne primary source of error in the velocity calculation was the reliance on a single, short time interval between pulses. Since the time interval measured between two consecutive pulses is quite small, minor variations or noise can lead to significant fluctuations in calculated speed. A more robust approach would involve measuring the time over several pulse intervals—e.g., capturing the cumulative time for n pulses and calculating velocity based on the average interval. Implementing this would likely improve the system’s accuracy without adding substantial complexity to the code, as it could be handled by a simple counter and cumulative timer mechanism within the interrupt routine.\nDespite these minor issues, the system achieved reliable performance in measuring and displaying the motor’s speed and direction, with USART output providing real-time feedback to the user.\n\n\n\nThis lab demonstrated a successful implementation of an interrupt-driven quadrature encoder interface on an MCU. By utilizing GPIO and timer configurations alongside external interrupts, the system was able to reliably track motor speed and direction, which were displayed via USART at a consistent update rate. I spent approximately 12 hours working on this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html#lab-5-interrupt",
    "href": "labs/lab5/lab5.html#lab-5-interrupt",
    "title": "hmc-e155-portforlio",
    "section": "",
    "text": "In Lab 5, the primary goal was to implement an interrupt-driven algorithm for reading quadrature encoder signals and converting them into motor velocity and direction readings. A quadrature encoder produces two offset pulse signals that can be interpreted to detect both the speed and direction of a rotating motor. By monitoring these signals, it is possible to determine whether the motor is moving clockwise or counter-clockwise and calculate the rotational speed in revolutions per second. This lab aims to accurately read these encoder pulses using interrupt-based routines on the MCU and display the measured speed and direction with a refresh rate of at least 1 Hz.\n\n\n\nThe design of this system primarily involved configuring two GPIO pins on the MCU to receive the quadrature encoder’s A and B signals, with PA5 and PA8 designated for this purpose. External interrupts (EXTI) were configured on these pins to detect falling edges, thus triggering an interrupt on each pulse received from the encoder. This enabled precise tracking of pulse events for calculating speed and determining the direction. The phase relationship between the two signals was used to infer the direction of rotation: when signal A leads signal B, the motor was identified as rotating clockwise, and vice versa for counter-clockwise.\nIn addition to the GPIO and EXTI setup, two timers were configured on the MCU. TIM16 was used to measure the time intervals between successive pulses, while TIM2 was configured to enforce a 0.5 Hz delay for the periodic display of results. The motor’s velocity in revolutions per second was calculated by inversely relating the interval time to speed, based on the formula speed = 1 / (0.000001 * interval * 120 * 4). This formula incorporated constants to account for the characteristics of the quadrature encoder, such as its pulses per revolution (120) and phase offsets (90°). Finally, the calculated velocity and direction were displayed via a USART output with a 0.5 Hz refresh rate.\n\n\n\nThe source code for the project can be found in the associated Github repository.  Figure 1. Flowchart illustrating the main steps of the program and function calls.\n Figure 2. Schematic of the physical circuit\n\n\n\nThe implemented system successfully captured the direction of motor rotation and calculated the rotational velocity, displaying these values on debug terminal with a 0.5 Hz refresh rate. The direction detection proved to be accurate due to the use of phase analysis between signals A and B, which consistently indicated whether the motor was moving clockwise or counter-clockwise. For the velocity measurement, the calculated speed in revolutions per second is closed to the motor’s actual speed but not very accurate.\nOne primary source of error in the velocity calculation was the reliance on a single, short time interval between pulses. Since the time interval measured between two consecutive pulses is quite small, minor variations or noise can lead to significant fluctuations in calculated speed. A more robust approach would involve measuring the time over several pulse intervals—e.g., capturing the cumulative time for n pulses and calculating velocity based on the average interval. Implementing this would likely improve the system’s accuracy without adding substantial complexity to the code, as it could be handled by a simple counter and cumulative timer mechanism within the interrupt routine.\nDespite these minor issues, the system achieved reliable performance in measuring and displaying the motor’s speed and direction, with USART output providing real-time feedback to the user.\n\n\n\nThis lab demonstrated a successful implementation of an interrupt-driven quadrature encoder interface on an MCU. By utilizing GPIO and timer configurations alongside external interrupts, the system was able to reliably track motor speed and direction, which were displayed via USART at a consistent update rate. I spent approximately 12 hours working on this lab."
  },
  {
    "objectID": "posts/lab1-post.html",
    "href": "posts/lab1-post.html",
    "title": "Lab 1 Blog",
    "section": "",
    "text": "What is something interesting you learned recently in lab or lecture? How do you feel like the course is helping you to grow as a person? Reflect on the character traits you listed at the beginning of the course for ideas about specific areas of growth to reflect on. What did you think about a recent AI prototype? How did your use of AI shape your thinking about what role these tools might play in the future of digital hardware design? Search the Internet for a recent article related to embedded systems. Reflect on those systems through the lens of what you’re learning in MicroPs. What are some ideas you’re thinking about exploring in your project and why?"
  }
]